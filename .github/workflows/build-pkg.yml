name: Build & Publish FreeBSD pkg repo

on:
  push:
    branches: [ "master" ]
    # Tag format:  os-<plugin>/<version>  e.g. os-wancarp/0.0.2
    tags:
      - "os-*/*"
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  # ───────────────────────────────────────────────────────────────────────────
  # JOB 1 – find every sub-directory that has a Makefile with PLUGIN_NAME set
  #          and turn it into a build-matrix.
  #          On a tag push only the tagged plugin is built.
  # ───────────────────────────────────────────────────────────────────────────
  discover:
    name: Discover plugins
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.scan.outputs.matrix }}
      is_release: ${{ steps.scan.outputs.is_release }}
      release_tag: ${{ steps.scan.outputs.release_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Scan for plugin Makefiles
        id: scan
        run: |
          REF="${{ github.ref }}"
          IS_RELEASE="false"
          RELEASE_TAG=""

          # Check if this is a tag push (refs/tags/os-<name>/<version>)
          if [[ "${REF}" == refs/tags/os-*/* ]]; then
            IS_RELEASE="true"
            RELEASE_TAG="${REF#refs/tags/}"   # e.g. os-wancarp/0.0.2
            PLUGIN_NAME="${RELEASE_TAG%%/*}"  # e.g. os-wancarp
            # Strip leading "os-" to match directory name
            DIR_NAME="${PLUGIN_NAME#os-}"     # e.g. wancarp

            # Find the matching plugin directory
            PLUGIN_DIR=""
            while IFS= read -r makefile; do
              dir=$(dirname "$makefile")
              name=$(grep '^PLUGIN_NAME' "$makefile" 2>/dev/null | awk '{print $2}')
              if [ "${name}" = "${DIR_NAME}" ]; then
                PLUGIN_DIR="${dir#./}"
                break
              fi
            done < <(find . -mindepth 2 -maxdepth 3 -name Makefile | sort)

            if [ -z "${PLUGIN_DIR}" ]; then
              echo "ERROR: no plugin directory found for tag ${RELEASE_TAG}" >&2
              exit 1
            fi
            json=$(python3 -c "import json; print(json.dumps({'include': [{'plugin_dir': '${PLUGIN_DIR}'}]}))")
          else
            # Normal push – build all plugins
            plugins=()
            while IFS= read -r makefile; do
              dir=$(dirname "$makefile")
              if grep -q '^PLUGIN_NAME' "$makefile" 2>/dev/null; then
                plugins+=("${dir#./}")
              fi
            done < <(find . -mindepth 2 -maxdepth 3 -name Makefile | sort)

            json=$(printf '%s\n' "${plugins[@]}" | \
              python3 -c "
          import sys, json
          dirs = [l.strip() for l in sys.stdin if l.strip()]
          print(json.dumps({'include': [{'plugin_dir': d} for d in dirs]}))
          ")
          fi

          echo "matrix=${json}"       >> "$GITHUB_OUTPUT"
          echo "is_release=${IS_RELEASE}" >> "$GITHUB_OUTPUT"
          echo "release_tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"
          echo "Found: ${json}  is_release=${IS_RELEASE}  tag=${RELEASE_TAG}"

  # ───────────────────────────────────────────────────────────────────────────
  # JOB 2 – build one .pkg per discovered plugin (runs in parallel)
  # ───────────────────────────────────────────────────────────────────────────
  build:
    name: Build ${{ matrix.plugin_dir }}
    needs: discover
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.discover.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4

      - name: Build FreeBSD .pkg inside a FreeBSD VM
        uses: vmactions/freebsd-vm@v1
        with:
          release: "14.3"
          usesh: true
          prepare: |
            pkg install -y pkg
          run: |
            set -e

            PLUGIN_DIR="${{ matrix.plugin_dir }}"

            PKG_NAME=$(   grep '^PLUGIN_NAME'    "${PLUGIN_DIR}/Makefile" | awk '{print $2}')
            PKG_VERSION=$(grep '^PLUGIN_VERSION' "${PLUGIN_DIR}/Makefile" | awk '{print $2}')
            PKG_COMMENT=$(grep '^PLUGIN_COMMENT' "${PLUGIN_DIR}/Makefile" | cut -d= -f2- | sed 's/^[[:space:]]*//')
            PKG_CATEGORY=$(echo "${PLUGIN_DIR}" | cut -d/ -f1)

            echo "==> Building os-${PKG_NAME}-${PKG_VERSION} from ${PLUGIN_DIR}"

            WORK="${GITHUB_WORKSPACE}/work/${PKG_NAME}"
            STAGE="${WORK}/stage"
            PKGS="${WORK}/pkgs"
            mkdir -p "${STAGE}/usr/local" "${PKGS}"

            # Stage all source files
            (cd "${PLUGIN_DIR}/src" && find . -type f) | while read -r FILE; do
              SRC="${PLUGIN_DIR}/src/${FILE#./}"
              DST="${STAGE}/usr/local/${FILE#./}"
              mkdir -p "$(dirname "${DST}")"
              cp "${SRC}" "${DST}"
            done

            # Make syshook scripts executable
            find "${STAGE}/usr/local/etc/rc.syshook.d" -type f \
              -exec chmod +x {} \; 2>/dev/null || true

            # plist
            PLIST="${WORK}/plist"
            (cd "${PLUGIN_DIR}/src" && find . -type f \
              | sed 's|^\./|/usr/local/|') > "${PLIST}"

            # +MANIFEST – use printf so YAML indentation is not affected
            # abi must match OPNsense's FreeBSD base: FreeBSD:14:amd64
            printf '%s\n' \
              "name: \"os-${PKG_NAME}\"" \
              "version: \"${PKG_VERSION}\"" \
              "origin: \"${PKG_CATEGORY}/os-${PKG_NAME}\"" \
              "comment: \"${PKG_COMMENT:-OPNsense plugin ${PKG_NAME}}\"" \
              "desc: \"${PKG_COMMENT:-OPNsense plugin ${PKG_NAME}}\"" \
              "maintainer: \"${{ github.actor }}@users.noreply.github.com\"" \
              "www: \"https://github.com/${{ github.repository }}\"" \
              "prefix: \"/usr/local\"" \
              "licenselogic: \"single\"" \
              "licenses: [ \"BSD2CLAUSE\" ]" \
              "abi: \"FreeBSD:14:amd64\"" \
              "arch: \"freebsd:14:x86:64\"" \
              > "${WORK}/+MANIFEST"

            # +DESC
            cp "${PLUGIN_DIR}/pkg-descr" "${WORK}/+DESC"

            # Build package
            pkg create \
              --root-dir "${STAGE}" \
              --manifest "${WORK}/+MANIFEST" \
              --plist    "${PLIST}" \
              --out-dir  "${PKGS}"

            ls -lh "${PKGS}"

      - name: Sanitise artifact name
        id: artifact_name
        run: |
          SAFE=$(echo "${{ matrix.plugin_dir }}" | tr '/' '_')
          echo "name=pkg--${SAFE}" >> "$GITHUB_OUTPUT"

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact_name.outputs.name }}
          path: work/*/pkgs/*.pkg

  # ───────────────────────────────────────────────────────────────────────────
  # JOB 3 – collect all .pkg files, run `pkg repo`, push to gh-pages
  # ───────────────────────────────────────────────────────────────────────────
  publish:
    name: Publish pkg repo to GitHub Pages
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          path: source

      - name: Checkout gh-pages (create if missing)
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages
        continue-on-error: true

      - name: Initialise gh-pages dir if branch did not exist yet
        run: |
          if [ ! -d gh-pages/.git ]; then
            rm -rf gh-pages
            mkdir gh-pages
            cd gh-pages
            git init -b gh-pages
            git remote add origin \
              "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          fi
          mkdir -p gh-pages/packages
          # Disable Jekyll so GitHub Pages serves ALL files (including binaries)
          touch gh-pages/.nojekyll
          # Remove stale .pkg files and repo metadata from previous runs
          rm -f gh-pages/packages/*.pkg gh-pages/packages/packagesite* \
                gh-pages/packages/data* gh-pages/packages/meta* \
                gh-pages/packages/*.conf
          # Remove any leftover nested dirs
          find gh-pages/packages -mindepth 1 -type d -exec rm -rf {} + 2>/dev/null || true

      - name: Download all package artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: pkg--*
          merge-multiple: true
          path: gh-pages/packages/download

      - name: Flatten downloaded packages into packages/
        run: |
          find gh-pages/packages/download -name '*.pkg' -exec mv {} gh-pages/packages/ \;
          rm -rf gh-pages/packages/download

      - name: Run pkg repo inside a FreeBSD VM
        uses: vmactions/freebsd-vm@v1
        with:
          release: "14.3"
          usesh: true
          prepare: |
            pkg install -y pkg
          run: |
            set -e
            cd "${GITHUB_WORKSPACE}/gh-pages/packages"
            pkg repo .
            ls -lh

      - name: Generate .conf files and landing page
        run: |
          REPO_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/packages"
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_FULL="${{ github.repository }}"
          REPO_NAME="${{ github.event.repository.name }}"

          # One repo config for ALL packages – valid FreeBSD/OPNsense UCL format
          # signature_type: none  →  no signing required for community repos
          printf '%s\n' \
            "opnsense-plugins-${REPO_OWNER}: {" \
            "  url: \"${REPO_URL}\"," \
            "  signature_type: \"none\"," \
            "  priority: 10," \
            "  enabled: yes" \
            "}" \
            > gh-pages/packages/opnsense-plugins.conf

          # Build HTML plugin list – only real plugin packages (os-*.pkg)
          # Skip pkg repo metadata files: data.pkg, packagesite.pkg, meta, etc.
          PKG_ROWS=""
          for PKG in gh-pages/packages/os-*.pkg; do
            [ -f "$PKG" ] || continue
            NAME=$(basename "$PKG" .pkg | sed 's/-[0-9].*//')
            VER=$( basename "$PKG" .pkg | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
            PKG_ROWS+="<tr><td><b>${NAME}</b></td><td>${VER}</td>"
            PKG_ROWS+="<td><code>pkg install ${NAME}</code></td></tr>\n"
          done

          cat > gh-pages/index.html <<EOF
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="utf-8">
            <title>${REPO_NAME} – OPNsense Plugin Repository</title>
            <style>
              body  { font-family: monospace; max-width: 860px; margin: 2em auto; padding: 0 1em; }
              pre   { background: #f4f4f4; padding: .8em; border-radius: 4px; overflow-x: auto; }
              table { border-collapse: collapse; width: 100%; }
              th,td { border: 1px solid #ccc; padding: .4em .7em; text-align: left; }
              th    { background: #f0f0f0; }
            </style>
          </head>
          <body>
          <h1>${REPO_NAME} – OPNsense FreeBSD pkg Repository</h1>
          <p>Built automatically from <a href="https://github.com/${REPO_FULL}">GitHub</a>
             on every push to <code>master</code>.</p>

          <h2>Setup</h2>
          <pre>
          # 1. Add repository (covers all plugins below)
          fetch -o /usr/local/etc/pkg/repos/${REPO_OWNER}-plugins.conf \
            ${REPO_URL}/opnsense-plugins.conf

          # 2. Install a plugin, e.g.:
          pkg update &amp;&amp; pkg install os-wancarp
          </pre>

          <h2>Repository URL</h2>
          <pre>${REPO_URL}</pre>

          <h2>Available plugins</h2>
          <table>
            <tr><th>Package</th><th>Version</th><th>Install</th></tr>
            $(printf "%b" "${PKG_ROWS}")
          </table>

          <p style="margin-top:2em;font-size:.85em">
            <a href="https://github.com/${REPO_FULL}">Source on GitHub</a>
          </p>
          </body>
          </html>
          EOF

      - name: Commit & push gh-pages
        run: |
          cd gh-pages
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "chore: publish pkg repo [skip ci]" || echo "Nothing to commit"
          git push origin HEAD:gh-pages --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ───────────────────────────────────────────────────────────────────────────
  # JOB 4 – create a GitHub Release with the .pkg as asset (tag pushes only)
  # ───────────────────────────────────────────────────────────────────────────
  release:
    name: Create GitHub Release
    needs: [ discover, build, publish ]
    if: needs.discover.outputs.is_release == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: pkg--*
          merge-multiple: true
          path: release-assets

      - name: Flatten to release-assets/
        run: find release-assets -mindepth 2 -name '*.pkg' -exec mv {} release-assets/ \;

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.discover.outputs.release_tag }}
          name: ${{ needs.discover.outputs.release_tag }}
          body: |
            ## ${{ needs.discover.outputs.release_tag }}

            Install via pkg repo (recommended):
            ```sh
            fetch -o /usr/local/etc/pkg/repos/opnsense-plugins.conf \
              https://chefkoch-de42.github.io/opnsense-plugins/packages/opnsense-plugins.conf

            pkg update && pkg install ${{ startsWith(needs.discover.outputs.release_tag, 'os-') && needs.discover.outputs.release_tag || format('os-{0}', needs.discover.outputs.release_tag) }}
            ```

            Or install the `.pkg` file directly (no repo needed):
            ```sh
            pkg add <direct-url-to-.pkg-file-from-assets-below>
            ```

            **pkg repo URL:** https://chefkoch-de42.github.io/opnsense-plugins/packages
          files: release-assets/*.pkg
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
